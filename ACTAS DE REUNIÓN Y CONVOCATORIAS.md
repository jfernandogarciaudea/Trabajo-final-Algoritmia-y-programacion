**Acta de Convocatoria a Reunión Para el Proyecto final**

Convocado por:  José Fernando García Galvis

Fecha: 06 / 09 / 2025

Dirigido a:

1. Carlos Andrés Castañeda Vélez
2. Eidys Marcela Guzman Arrieta
3. Katerine Rodríguez Vélez

Estimados Compañeros, 
Por medio de la presente, se les convoca a la primera reunión del equipo de trabajo para el proyecto final de Algoritmia y Programación.
Esta reunión se llevará a cabo el día Domingo 7 de septiembre del 2025 a las 4:00 PM, a través de la plataforma Meet, por medio del siguiente enlace https://meet.google.com/nsf-ksdw-gyv. 
El objetivo de esta reunión es:
1.	Revisar el instructivo del trabajo.
2.	Explorar el GitHub y compartir el proyecto con todos.
3.	Hacer un checklist de las actividades por hacer.
4.	Discutir cómo se colaborará para llevar a cabo la primera entrega del proyecto. 
5.	Plantear compromisos para trabajar las actividades de dicho proyecto.

Su asistencia es vital para el desarrollo del proyecto, por favor no falten.
Atentamente,

José Fernando García Galvis


**ACTA REUNIÓN DE TRABAJO 7 DE SEPTIEMBRE**

Fecha: 07 de septiembre de 2025

Hora: 4:00 PM a 5:30 PM

Lugar: Virtual por meet

Asistentes:
1. José Fernando García Galvis
2. Carlos Andrés Castañeda Vélez
3. Eidys Marcela Guzman Arrieta
4. Katerine Rodríguez velez 

Actividades Realizadas:
1. Revisión de rúbrica del trabajo: Se revisó la rúbrica del trabajo para asegurar que todos los miembros del equipo estén alineados con los objetivos y criterios de evaluación.
2. Exploración de GitHub: Se exploró el uso de GitHub para compartir el proyecto con todos los miembros del equipo y se discutieron las mejores prácticas para la colaboración.

Compromisos:
1. Nombre para el Cinema: Todos los miembros del equipo se comprometen a pensar en posibles nombres para el proyecto Cinema.

2. Configuración en GitHub:
- Todos los miembros deben revisar el enlace de colaboración de GitHub que se les envió (pendiente de envío al compañero que aún no proporciona su correo).
- Cada miembro debe completar su descripción personal en GitHub.

3. Elaboración de Actas:
- José Fernando: Elaborar un borrador del Acta de Entendimiento.
- Eidys: Elaborar un borrador del Acta de Colaboración.
- Katerine: Elaborar un borrador del Acta de Responsabilidad.

4. Revisión y Finalización:
- Cada responsable debe enviar su borrador de acta al grupo.
- Todos los miembros del equipo revisarán los borradores y contribuirán a su finalización.

Próxima Reunión: Sin definir, se piensa programar en cuanto se terminen los compromisos acordados

Cierre: Se da por concluida la reunión con la expectativa de avanzar en los compromisos establecidos y mantener una comunicación fluida para el éxito del proyecto.

Firma de los asistentes:

<img width="681" height="364" alt="image" src="https://github.com/user-attachments/assets/42b74e0d-6df5-4974-8a5a-1263cfb14bef" />



**Acta de Convocatoria a Reunión para seguimiento del proyecto**

Convocado por:  José Fernando García Galvis

Fecha: 26 / 09 / 2025

Dirigido a:

1. Carlos Andrés Castañeda Vélez
2. Eidys Marcela Guzman Arrieta
3. Katerine Rodríguez Vélez

Estimados Compañeros,

Por medio de la presente, se les convoca a una segunda reunión del equipo de trabajo para el proyecto final de Algoritmia y Programación.
Esta reunión se llevará a cabo el día Sábado 27 de septiembre del 2025 a las 8:00 AM, a través de la plataforma Meet, por medio del siguiente enlace https://meet.google.com/nbp-nfvc-vxd.

El objetivo de esta reunión es:
1.	Revisar el cumplimiento de los compromisos propuestos en la reunión anterior.
2.	Revisar las actividades faltantes.
3.	Dividir las actividades faltantes entre los miembros del equipo.
4.	Discutir la fecha de entrega de las actividades finales. 
5.	Plantear la próxima reunión para organizar la primera entrega del trabajo final.

Su asistencia es vital para para el desarrollo del proyecto, por favor no falten.
Atentamente,

José Fernando García Galvis


**ACTA DE SEGUNDA REUNIÓN PARA PROYECTO CINE AGORA**

Fecha: 27 de septiembre de 2025

Hora: 8:00 AM a 8:30 AM

Lugar: Virtual por Meet

Asistentes:
1. José Fernando García Galvis
2. Carlos Andrés Castañeda Vélez
3. Eidys Marcela Guzman Arrieta
4. Katerine Rodríguez Vélez 

Actividades Realizadas:
1. Revisión de compromisos anteriores: Se revisó que todos los miembros del equipo cumplieran con los compromisos pactados en la reunión anterior.
2. Revision de las actas: Se hizo la revision conjunta de los borradores de las actas que se habian hecho hasta el momento.
3. Revisión de actividades faltantes: Se hizo una revisión en el checklist de las actividades faltantes, además de hacer la distribución de dichas actividades entre los miembros del grupo.

Compromisos:
1. Fecha de entrega de las actividades faltantes: Todos los miembros del equipo deben enviar las actividades asignadas a más tardar el día lunes 29/09/2025 para así revisar y organizar todo antes de la fecha de la entrega. 
2. Asignación de las actividades faltantes:
- Katerine: Hacer el reporte de visión
Carlos: Hacer especificación de requisitos
José Fernando: Hacer el plan de proyecto
Eidys: Plasmar la convocatoria de las reuniones realizadas y hacer acta de esta reunión.
Próxima Reunión: La próxima reunión se acordó para el día Martes 30/09/2025, aun queda por definir la hora de esta reunión.

Se da por concluida la reunión con la expectativa de avanzar en los compromisos establecidos y mantener una comunicación fluida para el éxito del proyecto.

Firma de los asistentes:

<img width="681" height="364" alt="image" src="https://github.com/user-attachments/assets/cf9a559d-d01a-48a1-a2d2-4cbfda43d621" />


ACTA DE REUNIÓN – EXPLICACIÓN DETALLADA DEL CÓDIGO DEL SISTEMA “CINE ÁGORA”

Fecha: 25 de octubre de 2025
Hora: 8:00 AM – 1:00 pm
Modalidad: Reunión virtual por Google Meet
Proyecto: Sistema de gestión de cine “Cine Ágora”
Convoca: José Fernando García Galvis

Asistentes:

José Fernando García Galvis

Carlos Andrés Castañeda Vélez

Eidys Marcela Guzmán Arrieta

Katerine Rodríguez Vélez

1. Objetivo de la reunión

Documentar y explicar de manera detallada la construcción del código del sistema “Cine Ágora”, indicando para qué se utiliza cada tipo de instrucción y cada bloque principal del programa: import, def, print, input, if/elif/else, ciclos for y while, diccionarios, defaultdict, funciones de validación, manejo de errores con try/except, estadísticas, menú de administrador y bloque de ejecución final.

2. Explicación de los componentes del código
2.1 Importación de librerías

Se explicó que al inicio del archivo se usaron:

import datetime

from collections import defaultdict, Counter

Uso:

datetime permite obtener la fecha y hora actual que se guarda en cada reserva (fecha_actual_str()).

defaultdict(list) se usa para que el diccionario reservas_usuario cree automáticamente una lista vacía por cada usuario sin tener que inicializarla manualmente.

Counter se utiliza en el módulo de estadísticas para contar cuántas reservas tiene cada usuario, lo que permite identificar al usuario con mayor y menor número de reservas.

2.2 Constantes y configuraciones iniciales

Se definieron:

FILAS y COLUMNAS: se crean con ciclos sobre letras para armar la matriz de sillas (por ejemplo A–K).

PRECIOS_BOLETOS: diccionario con el precio según el tipo de vínculo.

CREDENCIALES_ADMIN: diccionario donde se asocian usuarios administradores con su contraseña.

Uso del código:

Aquí se utilizan diccionarios porque permiten acceder rápido a la información mediante una clave (tipo de vínculo → precio, usuario admin → contraseña).

También se usan operaciones como len() para saber cuántas filas y columnas tiene la sala.

2.3 Estructuras de datos principales

Se explicaron los diccionarios:

usuarios = {} → guarda nombre, apellido, documento, tipo_vinculo y fecha_registro.

funciones = {} → contiene la información de cada función: id, día, hora, película, sillas y disponibles.

reservas = {} → cada reserva tiene: id, doc_usuario, id_funcion, id_silla, fecha_hora, precio, activa.

reservas_usuario = defaultdict(list) → relaciona cada documento con la lista de IDs de reserva.

_estadisticas = { ... } → acumula totales de reservas creadas, tiquetes vendidos y valor pagado.

Justificación:
Se acordó que los diccionarios permiten manejar información relacionada y acceder a ella mediante claves, lo que facilita las búsquedas y actualizaciones.

2.4 Uso de variables globales y funciones auxiliares

_contador_reservas y _contador_funciones: se usan como contadores globales para crear IDs únicos.

Funciones:

siguiente_id_reserva() y siguiente_id_funcion(): usan la palabra global para modificar los contadores y luego return para devolver el nuevo ID.

fecha_actual_str(): usa datetime.datetime.now().strftime() para obtener la fecha y hora formateada.

nombre_valido(), documento_valido(): usan métodos como .strip(), .isalpha(), .isdigit() y len() para validar textos y números.

Uso del código:

def define cada función.

return indica el valor que la función “regresa” al punto donde fue llamada.

Los métodos .strip(), .upper(), .lower() se usan para limpiar y estandarizar entradas del usuario.

2.5 Validación de entrada del usuario

Se creó la función:

def entrada_no_vacia(prompt):
    while True:
        val = input(prompt).strip()
        if val:
            return val
        print("Entrada vacía. Intente de nuevo.")


Explicación de códigos usados:

input() captura lo que el usuario digita.

while True: crea un ciclo infinito hasta que se reciba un valor válido.

if val: comprueba que la cadena no esté vacía.

return devuelve el valor correcto.

print() informa al usuario cuando debe volver a intentar.

2.6 Inicialización de funciones y sillas

En funciones_iniciales() se definió una lista de películas con día y hora, y luego mediante:

for idx, (dia, hora, peli) in enumerate(muestra):
    ...
    for f in FILAS:
        for c in COLUMNAS:
            sillas[f"{f}{c}"] = 'O'


se explicó:

El uso de for anidados para recorrer filas y columnas y crear todas las sillas (A1, A2, B1, B2, etc.).

El uso de 'O' para indicar silla ocupada o libre según la lógica del sistema (por ejemplo, ‘O’ para libre y ‘X’ para ocupada).

enumerate() permite obtener un índice automático para generar el ID de la función.

2.7 Presentación visual y menú principal

Se revisaron las funciones:

imprimir_banner() y el menú principal que se muestra con varios print() numerando opciones.

mostrar_asientos(func): usa un encabezado con las columnas y luego recorre las filas con for, construyendo cada línea con join() y f-strings.

Uso clave de código:

f"{variable}" (f-strings) para formatear cadenas de texto con variables adentro.

join() para unir varios elementos en un solo texto.

Manejo de índices para mostrar información ordenada.

2.8 Selección de funciones y manejo de hora

En seleccionar_funcion_por_id() se explicó:

Se ordenan las funciones con sorted() usando una función key que combina orden_dia() y hora_a_24().

Uso de try y except:

try:
    eleccion = int(input("Ingrese el Id de la función que desea seleccionar: ").strip())
except Exception:
    print("Entrada inválida. Ingrese un número.")


Justificación:

try/except evita que el programa se caiga cuando el usuario escribe algo que no es número.

int() convierte la entrada de texto a entero.

orden_dia() convierte palabras como “Viernes”, “Sábado” en un número para ordenarlas.

hora_a_24() transforma horas tipo “2pm” o “10:00am” a formato 24 horas para poder compararlas.

2.9 Registro de usuarios

En registrar_usuario() se explicó el uso conjunto de:

print() → mensajes y título del módulo.

entrada_no_vacia() → para leer nombre, apellido y documento.

if not nombre_valido(nombre): → ejemplo de validación con if.

for t, p in PRECIOS_BOLETOS.items(): → bucle para mostrar tipos de vínculo y su precio.

Diccionario usuarios[documento] = { ... } → guarda los datos del usuario.

Si hay errores de validación, se almacenan en la lista errores y luego se imprimen con otro for.

2.10 Interpretación del asiento

La función interpretar_asiento() permite aceptar entradas como “A3”, “A B” o “AB”:

Se usan operaciones de cadenas (.replace(), .upper()) para limpiar espacios.

Se separan letra y número para verificar con if letra in FILAS y if número en COLUMNAS.

Si la entrada es inválida, la función retorna None, y en registrar_reserva se verifica con if not id_silla: para cancelar el proceso.

2.11 Registro y cancelación de reservas

En registrar_reserva() se repasó:

Verificación de que el usuario exista: if documento not in usuarios:.

Llamado a seleccionar_funcion_por_id() y mostrar_asientos(func).

Verificación de disponibilidad del asiento: if func['sillas'][id_silla] == 'X': → significa silla ocupada.

Asignación de asiento: func['sillas'][id_silla] = 'X'.

Descuento de cupos: func['disponibles'] -= 1.

Cálculo de precio usando el diccionario PRECIOS_BOLETOS.

Actualización de estadísticas: sumas y contadores.

En cancelar_reserva():

Se obtiene la lista de reservas activas del usuario con comprensión de listas.

Se usa nuevamente try/except para leer el ID de reserva a cancelar.

Se cambia el estado de activa a False y se marca la silla como libre ('O').

Se actualizan las variables estadísticas restando un tiquete vendido.

2.12 Módulo de administración y estadísticas

En acceso_admin() y menu_admin() se muestra el uso de:

Comparación de usuario y contraseña con if CREDENCIALES_ADMIN.get(usuario) == pwd:.

Menú administrativo con varias opciones de print() y input().

Función promedio_venta_diario() que:

Recorre las reservas con for.

Usa un set() para obtener días diferentes.

Divide total_pago_realizado entre el número de días.

En estadisticas_reservas_usuario() se usa Counter:

cont = Counter()
for doc, lst in reservas_usuario.items():
    cont[doc] = len(lst)


Después se obtiene el usuario con más y menos reservas usando max() y min() sobre el contador.

imprimir_todas_reservas() recorre el diccionario reservas y muestra cada reserva utilizando f-strings para presentar película, día, hora, asiento, precio y estado (“Activa” o “Cancelada”).

2.13 Ciclo principal y salida del sistema

La función ciclo_principal() contiene un:

while True:
    imprimir_banner()
    op = entrada_no_vacia("Seleccione una opción (1-6): ")
    if op == '1':
        registrar_usuario()
    elif op == '2':
        registrar_reserva()
    ...
    elif op == '6':
        print("Gracias por usar el sistema. Hasta luego.")
        break


Explicación:

while True mantiene el menú en pantalla hasta que el usuario elija salir.

if/elif/else decide qué función se ejecuta según el número digitado.

break rompe el ciclo y termina el programa.

Finalmente, el bloque:

if __name__ == "__main__":
    print("Iniciando sistema Cine Ágora (ejecución en consola).")
    ciclo_principal()


asegura que el sistema se ejecute solo cuando el archivo es el programa principal, cumpliendo una buena práctica de programación.

3. Conclusiones

El equipo dejó claramente documentado para qué se utiliza cada construcción del lenguaje de programación dentro del sistema “Cine Ágora”.

Se evidenció el uso correcto de:

Entradas y salidas (input, print),

Estructuras de decisión (if, elif, else),

Ciclos (for, while),

Funciones (def, return),

Estructuras de datos (diccionarios, listas, defaultdict, Counter),

Manejo de errores (try/except),

Separación por módulos (usuario, reservas, administración, estadísticas y menú principal).

El programa se encuentra funcional y listo para ser presentado como proyecto final de la asignatura.

4. Compromisos

Se mantienen los compromisos establecidos: pruebas finales, elaboración del informe escrito, construcción de diagrama de flujo y preparación de la sustentación.

5. Firma de los asistentes
<img width="681" height="364" alt="image" src="https://github.com/user-attachments/assets/cf9a559d-d01a-48a1-a2d2-4cbfda43d621" />
